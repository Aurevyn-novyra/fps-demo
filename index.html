<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Single‚ÄëFile FPS ‚Äî GitHub Pages Ready</title>
  <style>
    :root {
      --hud: rgba(0,0,0,.55);
      --accent: #00ffd0;
      --danger: #ff4d4d;
      --ok: #8aff8a;
      --warn: #ffd166;
    }
    html, body { margin: 0; height: 100%; overflow: hidden; background: #000; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    canvas { display: block; }

    /* HUD */
    #hud { position: fixed; inset: 0; pointer-events: none; }
    .panel { position: absolute; background: var(--hud); color: #fff; padding: 8px 12px; border-radius: 12px; backdrop-filter: blur(6px); box-shadow: 0 6px 24px rgba(0,0,0,.4); }
    #stats { left: 12px; top: 12px; display: grid; gap: 6px; }
    #stats .row { display: flex; gap: 10px; align-items: center; }
    .bar { width: 180px; height: 10px; background: rgba(255,255,255,.15); border-radius: 99px; overflow: hidden; }
    .bar > i { display:block; height:100%; background: linear-gradient(90deg, var(--ok), #29b6f6); }
    .ammo { font-weight: 700; font-variant-numeric: tabular-nums; }
    #wave { right: 12px; top: 12px; text-align: right; }
    #crosshair { position: absolute; left: 50%; top: 50%; translate: -50% -50%; width: 14px; height: 14px; border-radius: 999px; outline: 2px solid rgba(255,255,255,.9); outline-offset: -6px; box-shadow: 0 0 10px rgba(0,0,0,.8); }
    #reticle::before, #reticle::after { content: ""; position: absolute; left: 50%; top: 50%; width: 16px; height: 2px; background: rgba(255,255,255,.8); }
    #reticle::before { translate: -50% -11px; }
    #reticle::after { translate: -50% 9px; }

    #hint { left: 50%; bottom: 28px; translate: -50% 0; text-align: center; }
    #controls { right: 12px; bottom: 12px; font-size: 12px; opacity: .85; }
    .pill { display:inline-block; border: 1px solid rgba(255,255,255,.35); padding: 2px 8px; border-radius: 999px; margin: 2px; }

    /* Pause overlay */
    #overlay { position: fixed; inset: 0; background: linear-gradient(180deg, rgba(0,0,0,.8), rgba(0,0,0,.5)); color:#fff; display: grid; place-items: center; gap: 18px; }
    #overlay h1 { margin: 0 0 8px; font-size: clamp(24px, 3vw, 42px); letter-spacing: .5px; }
    #overlay .card { background: rgba(12,12,12,.6); padding: 22px 24px; border-radius: 18px; box-shadow: 0 10px 40px rgba(0,0,0,.5); text-align: center; max-width: 720px; }
    #overlay button { pointer-events:auto; background: #111; border: 1px solid rgba(255,255,255,.25); color:#fff; border-radius: 12px; padding: 10px 16px; font-weight: 700; cursor: pointer; transition: transform .1s ease, box-shadow .2s ease; }
    #overlay button:hover { transform: translateY(-1px); box-shadow: 0 8px 24px rgba(0,0,0,.4); }
    #overlay .grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 12px; margin-top: 12px; font-size: 14px; }
    #overlay .kbd { background: #222; border: 1px solid rgba(255,255,255,.25); padding: 2px 8px; border-radius: 8px; }

    /* Notifications */
    #toasts { position: fixed; left: 50%; top: 10px; translate: -50% 0; display: grid; gap: 8px; }
    .toast { background: rgba(0,0,0,.7); color: #fff; padding: 8px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,.12); font-weight: 600; }

    /* Mobile helper */
    @media (max-width: 820px) {
      #controls { display:none; }
    }
  </style>
</head>
<body>
  <div id="overlay">
    <div class="card">
      <h1>Single‚ÄëFile FPS</h1>
      <p>Click <b>Enter Arena</b> and then click/tap once inside to lock the mouse. Survive waves, collect crates, and use Adrenaline (slow‚Äëmo) wisely.</p>
      <div class="grid">
        <div>Move: <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span></div>
        <div>Jump: <span class="kbd">Space</span></div>
        <div>Shoot: <span class="kbd">Left Click</span></div>
        <div>Reload: <span class="kbd">R</span></div>
        <div>Adrenaline (Slow‚Äëmo): <span class="kbd">Q</span></div>
        <div>Pause/Unlock: <span class="kbd">Esc</span></div>
      </div>
      <p style="opacity:.85;margin-top:10px">Built with Three.js ‚Äî zero assets, runs anywhere (GitHub Pages ready).</p>
      <button id="start">Enter Arena</button>
    </div>
  </div>

  <div id="hud">
    <div id="stats" class="panel">
      <div class="row">üíó Health
        <div class="bar"><i id="hpbar" style="width:100%"></i></div>
      </div>
      <div class="row">üî´ Ammo <span id="ammo" class="ammo">30 / 90</span></div>
      <div class="row">‚≠ê Score <span id="score" class="ammo">0</span></div>
      <div class="row">‚ö° Adrenaline <span id="adren" class="ammo">100%</span></div>
    </div>
    <div id="wave" class="panel">Wave <span id="waveNo">1</span><br><span id="status">Prepare...</span></div>
    <div id="hint" class="panel">Press <b>Q</b> for slow‚Äëmo. Grab green crates for ammo/health. Avoid red lava tiles!</div>
    <div id="controls" class="panel">
      <div><span class="pill">WASD</span> move ‚Ä¢ <span class="pill">Space</span> jump ‚Ä¢ <span class="pill">Q</span> slow‚Äëmo ‚Ä¢ <span class="pill">R</span> reload</div>
    </div>
    <div id="crosshair">
      <div id="reticle"></div>
    </div>
    <div id="toasts"></div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.159.0/build/three.module.js';
    import { PointerLockControls } from 'https://unpkg.com/three@0.159.0/examples/jsm/controls/PointerLockControls.js';

    // --- Helpers ---
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
    const rand = (min, max) => Math.random() * (max - min) + min;
    const choice = (arr) => arr[(Math.random() * arr.length) | 0];

    // --- Scene Setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x070707);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 2000);
    camera.position.set(0, 1.6, 6);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const controls = new PointerLockControls(camera, document.body);

    const world = new THREE.Group();
    scene.add(world);

    // Lighting
    const hemi = new THREE.HemisphereLight(0x88ccee, 0x332211, 0.6);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(6, 12, 6);
    dir.castShadow = true;
    dir.shadow.mapSize.set(2048, 2048);
    scene.add(dir);

    // Floor (with some lava hazard tiles)
    const floorGeom = new THREE.PlaneGeometry(200, 200, 20, 20);
    floorGeom.rotateX(-Math.PI/2);
    const floorMat = new THREE.MeshStandardMaterial({ color: 0x0d0d0f, metalness: .1, roughness: .9 });
    const floor = new THREE.Mesh(floorGeom, floorMat);
    floor.receiveShadow = true;
    world.add(floor);

    // Grid helper + sporadic neon lines for style
    const grid = new THREE.GridHelper(200, 80, 0x0efcff, 0x0efcff);
    grid.material.opacity = 0.08; grid.material.transparent = true;
    world.add(grid);

    // Random pillars for cover
    const pillars = new THREE.Group();
    world.add(pillars);
    const pillarMat = new THREE.MeshStandardMaterial({ color: 0x333a40, roughness:.8, metalness:.2 });
    for (let i=0;i<45;i++){
      const h = rand(2,6);
      const m = new THREE.Mesh(new THREE.BoxGeometry(1, h, 1), pillarMat);
      m.position.set(rand(-80,80), h/2, rand(-80,80));
      m.castShadow = m.receiveShadow = true;
      pillars.add(m);
    }

    // Ambient FX: rotating sky light ring
    const ringGeo = new THREE.TorusGeometry(30, 0.3, 16, 100);
    const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ffd0, transparent:true, opacity:.07 });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.position.y = 20; ring.rotation.x = Math.PI/2;
    world.add(ring);

    // Hazards: lava tiles (simple damage zones)
    const hazards = [];
    const lavaMat = new THREE.MeshStandardMaterial({ color: 0xff2b2b, emissive: 0x660000, emissiveIntensity: 1, metalness:.2, roughness:.6 });
    for (let i=0;i<30;i++){
      const g = new THREE.Mesh(new THREE.PlaneGeometry(6,6), lavaMat);
      g.rotation.x = -Math.PI/2; g.position.set(rand(-70,70), 0.01, rand(-70,70));
      g.userData = { type: 'lava' };
      world.add(g); hazards.push(g);
    }

    // Player state
    const state = {
      hp: 100,
      score: 0,
      ammo: 30,
      reserve: 90,
      magSize: 30,
      canShoot: true,
      fireRate: 8, // bullets per second
      reloadTime: 1.2,
      adren: 100, // percentage
      slowmo: false,
      wave: 1,
      gameOver: false,
    };

    // UI elements
    const hpbar = document.getElementById('hpbar');
    const ammoEl = document.getElementById('ammo');
    const scoreEl = document.getElementById('score');
    const adrenEl = document.getElementById('adren');
    const waveEl = document.getElementById('waveNo');
    const statusEl = document.getElementById('status');
    const toasts = document.getElementById('toasts');

    function updateHUD(){
      hpbar.style.width = `${clamp(state.hp,0,100)}%`;
      hpbar.style.background = state.hp < 30 ? 'linear-gradient(90deg, var(--danger), #ff8a80)' : 'linear-gradient(90deg, var(--ok), #29b6f6)';
      ammoEl.textContent = `${state.ammo} / ${state.reserve}`;
      scoreEl.textContent = `${state.score}`;
      adrenEl.textContent = `${Math.round(state.adren)}%`;
      waveEl.textContent = `${state.wave}`;
    }

    function toast(msg){
      const t = document.createElement('div'); t.className='toast'; t.textContent=msg; toasts.appendChild(t);
      setTimeout(()=>{ t.remove(); }, 2000);
    }

    // Controls
    const keys = new Set();
    const velocity = new THREE.Vector3();
    let onGround = true; // simple grounded flag

    document.addEventListener('keydown', (e)=>{
      if(e.repeat) return;
      keys.add(e.code);
      if(e.code === 'KeyQ') toggleSlowmo();
      if(e.code === 'KeyR') reload();
    });
    document.addEventListener('keyup', (e)=> keys.delete(e.code));

    // Pointer lock
    const overlay = document.getElementById('overlay');
    document.getElementById('start').addEventListener('click', ()=>{
      overlay.style.display = 'none';
      controls.lock();
    });

    controls.addEventListener('lock', ()=>{ document.body.requestPointerLock?.(); });
    controls.addEventListener('unlock', ()=>{ overlay.style.display = 'grid'; });

    // Gun muzzle flash (simple sprite)
    const muzzleGeo = new THREE.PlaneGeometry(0.35, 0.35);
    const muzzleMat = new THREE.MeshBasicMaterial({ color: 0xffffcc, transparent:true, opacity:0, side: THREE.DoubleSide });
    const muzzle = new THREE.Mesh(muzzleGeo, muzzleMat);
    muzzle.position.set(0.35, -0.25, -0.6);
    camera.add(muzzle); scene.add(camera);

    // Enemies & projectiles
    const enemies = []; // {mesh, hp, speed, kind}
    const shots = [];   // player projectiles (visual tracers)
    const enemyBullets = [];

    const enemyMatRunner = new THREE.MeshStandardMaterial({ color: 0xff4444, metalness:.1, roughness:.7 });
    const enemyMatShooter = new THREE.MeshStandardMaterial({ color: 0xff9f1c, metalness:.1, roughness:.7 });

    function spawnEnemy(kind='runner'){
      const geo = new THREE.BoxGeometry(1,1.6,1);
      const mat = kind==='runner'? enemyMatRunner: enemyMatShooter;
      const m = new THREE.Mesh(geo, mat); m.castShadow = true; m.receiveShadow=true;
      const r = rand(18, 35);
      const ang = rand(0, Math.PI*2);
      m.position.set(Math.cos(ang)*r, 0.8, Math.sin(ang)*r);
      const hp = kind==='runner'? 30: 50;
      const speed = kind==='runner'? rand(2.2, 3.2): rand(1.3, 1.8);
      world.add(m);
      enemies.push({ mesh: m, hp, speed, kind, shootCd: rand(1,2) });
    }

    function spawnWave(n){
      for(let i=0;i<n;i++) spawnEnemy(Math.random()<0.3? 'shooter':'runner');
      statusEl.textContent = 'Enemies inbound!';
    }

    // Crates (powerups)
    const crates = [];
    const crateMat = new THREE.MeshStandardMaterial({ color: 0x00ffd0, emissive: 0x004d40, emissiveIntensity: .4, metalness:.2, roughness:.5 });
    function spawnCrate(){
      const c = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.8,0.8), crateMat);
      c.position.set(rand(-20,20), 0.4, rand(-20,20)); c.castShadow = c.receiveShadow = true;
      c.userData = { type: choice(['heal','ammo','adren','random']) };
      world.add(c); crates.push(c);
    }

    // Boss (simple big cube with more hp)
    let boss = null;
    function spawnBoss(){
      const m = new THREE.Mesh(new THREE.BoxGeometry(3,4,3), new THREE.MeshStandardMaterial({ color: 0x9c27b0, metalness:.1, roughness:.6 }));
      m.position.set(rand(-25,25), 2, rand(-25,25)); m.castShadow = m.receiveShadow = true;
      world.add(m); boss = { mesh: m, hp: 400, speed: 0.9 };
      toast('BOSS ARRIVED ‚Äî stay sharp!');
    }

    // Shooting
    let lastShot = 0;
    function shoot(time){
      if(!state.canShoot || state.ammo<=0) return;
      const interval = 1/state.fireRate * 1000; // ms
      if(time - lastShot < interval) return;
      lastShot = time; state.ammo--; updateHUD();

      // Muzzle flash
      muzzle.material.opacity = 1; setTimeout(()=> muzzle.material.opacity = 0, 40);

      // Raycast hit scan
      const ray = new THREE.Raycaster();
      ray.setFromCamera(new THREE.Vector2(0,0), camera);
      const targets = [ ...enemies.map(e=>e.mesh), ...(boss?[boss.mesh]:[]), ...pillars.children ];
      const hit = ray.intersectObjects(targets, false)[0];

      // Visual tracer (line)
      const p1 = camera.getWorldPosition(new THREE.Vector3());
      const p2 = hit? hit.point.clone(): camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(100).add(p1);
      const geo = new THREE.BufferGeometry().setFromPoints([p1, p2]);
      const mat = new THREE.LineBasicMaterial({ transparent:true, opacity:.8 });
      const line = new THREE.Line(geo, mat); world.add(line); shots.push({ line, ttl: 60 });

      if(hit){
        // Damage logic
        const dmg = state.slowmo? 45: 25;
        let killed = false;
        for(const e of enemies){
          if(e.mesh === hit.object){ e.hp -= dmg; if(e.hp<=0){
            killed = true; world.remove(e.mesh); enemies.splice(enemies.indexOf(e),1); state.score += 5; updateHUD();
          } break; }
        }
        if(!killed && boss && hit.object === boss.mesh){
          boss.hp -= (state.slowmo? 30: 18);
          if(boss.hp<=0){ world.remove(boss.mesh); boss = null; state.score += 100; toast('Boss down!'); updateHUD(); }
        }
      }
    }

    function reload(){
      if(state.ammo === state.magSize || state.reserve<=0) return;
      state.canShoot = false; toast('Reloading...');
      setTimeout(()=>{
        const need = state.magSize - state.ammo;
        const take = Math.min(need, state.reserve);
        state.ammo += take; state.reserve -= take; state.canShoot = true; updateHUD();
      }, state.reloadTime * 1000);
    }

    function toggleSlowmo(){
      if(state.adren < 20) { toast('Not enough Adrenaline'); return; }
      state.slowmo = !state.slowmo; toast(state.slowmo? 'Adrenaline ON ‚Äî time dilates' : 'Adrenaline OFF');
    }

    // Mouse shoot
    window.addEventListener('mousedown', e=>{ if(controls.isLocked) shoot(performance.now()); });

    // Resize
    window.addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight);
    });

    // Basic physics-ish params
    const speed = 6; const jumpVel = 7; const gravity = 20;

    // Wave control
    let nextWaveIn = 0; // frames
    let enemiesPerWave = 6;

    function nextWave(){
      state.wave++; enemiesPerWave = Math.round(enemiesPerWave * 1.2 + 1);
      spawnWave(enemiesPerWave);
      if(state.wave % 3 === 0 && !boss) spawnBoss();
      spawnCrate(); spawnCrate();
    }

    // Game loop
    let last = performance.now();

    function step(){
      if(state.gameOver){ renderer.render(scene, camera); requestAnimationFrame(step); return; }
      const now = performance.now();
      let dt = (now - last) / 1000; last = now;
      const timeScale = state.slowmo? 0.35 : 1;
      dt *= timeScale;

      ring.rotation.z += 0.02 * dt / 0.016; // subtle sky movement

      // Adrenaline drain/regain
      if(state.slowmo){ state.adren = clamp(state.adren - 20*dt, 0, 100); if(state.adren<=0){ state.slowmo=false; toast('Adrenaline depleted'); } }
      else { state.adren = clamp(state.adren + 8*dt, 0, 100); }

      // Movement
      const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y=0; forward.normalize();
      const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).negate();

      const acc = new THREE.Vector3();
      if(keys.has('KeyW')) acc.add(forward);
      if(keys.has('KeyS')) acc.add(forward.clone().negate());
      if(keys.has('KeyA')) acc.add(right.clone().negate());
      if(keys.has('KeyD')) acc.add(right);
      acc.normalize().multiplyScalar(speed);

      velocity.x = acc.x; velocity.z = acc.z;
      if(onGround && keys.has('Space')){ velocity.y = jumpVel; onGround = false; }
      velocity.y -= gravity * dt;

      const pos = camera.position.clone();
      pos.addScaledVector(velocity, dt);

      // Ground clamp & lava damage
      if(pos.y <= 1.6){ pos.y = 1.6; velocity.y = 0; onGround = true; }
      for(const l of hazards){
        if(Math.abs(pos.x - l.position.x) < 3 && Math.abs(pos.z - l.position.z) < 3){
          state.hp -= 10 * dt; if(state.hp<=0) gameOver();
        }
      }

      // Simple pillar collision (AABB vs point)
      for(const p of pillars.children){
        const a = p.position.x - 0.6, b = p.position.x + 0.6;
        const c = p.position.z - 0.6, d = p.position.z + 0.6;
        if(pos.x > a && pos.x < b && pos.z > c && pos.z < d){
          // push back
          if(Math.abs(camera.position.x - a) < Math.abs(camera.position.x - b)) pos.x = a - 0.01; else pos.x = b + 0.01;
          if(Math.abs(camera.position.z - c) < Math.abs(camera.position.z - d)) pos.z = c - 0.01; else pos.z = d + 0.01;
        }
      }

      camera.position.copy(pos);

      // Enemy AI
      for(const e of enemies){
        const dirv = camera.position.clone().sub(e.mesh.position); dirv.y = 0; const dist = dirv.length(); dirv.normalize();
        e.mesh.lookAt(camera.position.x, 0.8, camera.position.z);
        if(e.kind==='runner'){
          e.mesh.position.addScaledVector(dirv, e.speed*dt);
        } else {
          // shooter keeps distance
          if(dist>9) e.mesh.position.addScaledVector(dirv, e.speed*dt);
          if(dist<6) e.mesh.position.addScaledVector(dirv, -e.speed*dt);
          // fire
          e.shootCd -= dt; if(e.shootCd<=0 && dist<35){
            e.shootCd = rand(1.3,2.2);
            const from = e.mesh.position.clone(); from.y = 1.2;
            const to = camera.position.clone();
            const v = to.sub(from).normalize().multiplyScalar(22);
            const geom = new THREE.SphereGeometry(0.08, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffdd55 });
            const b = new THREE.Mesh(geom, mat); b.position.copy(from); world.add(b);
            enemyBullets.push({ mesh: b, vel: v, ttl: 5 });
          }
        }
        // damage if too close
        if(dist < 1.4){ state.hp -= 15*dt; if(state.hp<=0) gameOver(); }
      }

      // Enemy bullets update
      for(let i=enemyBullets.length-1;i>=0;i--){
        const b = enemyBullets[i]; b.mesh.position.addScaledVector(b.vel, dt);
        b.ttl -= dt; if(b.ttl<=0){ world.remove(b.mesh); enemyBullets.splice(i,1); continue; }
        if(b.mesh.position.distanceTo(camera.position) < 1){ state.hp -= 20; world.remove(b.mesh); enemyBullets.splice(i,1); if(state.hp<=0) gameOver(); }
      }

      // Shots visual fade
      for(let i=shots.length-1;i>=0;i--){ const s = shots[i]; s.ttl -= 60*dt; s.line.material.opacity = s.ttl/60; if(s.ttl<=0){ world.remove(s.line); shots.splice(i,1); } }

      // Crate pickup
      for(let i=crates.length-1;i>=0;i--){ const c = crates[i];
        if(c.position.distanceTo(camera.position) < 1.5){
          const t = c.userData.type; world.remove(c); crates.splice(i,1);
          if(t==='heal'){ state.hp = clamp(state.hp + 40, 0, 100); toast('Heal +40'); }
          else if(t==='ammo'){ state.reserve += 45; toast('Ammo +45'); }
          else if(t==='adren'){ state.adren = clamp(state.adren + 60, 0, 100); toast('Adrenaline +60'); }
          else { // random
            const effect = choice(['doubleFire','nuke','shieldSmall']);
            if(effect==='doubleFire'){ const old = state.fireRate; state.fireRate = old*1.7; toast('Rapid Fire 10s'); setTimeout(()=> state.fireRate = old, 10000); }
            if(effect==='nuke'){ // damage all enemies
              for(const e of enemies){ e.hp -= 20; if(e.hp<=0){ world.remove(e.mesh); enemies.splice(enemies.indexOf(e),1); state.score += 5; }} toast('EMP Detonation!'); }
            if(effect==='shieldSmall'){ state.hp = clamp(state.hp + 20, 0, 100); toast('Shield +20'); }
          }
          updateHUD();
        }
      }

      // Wave / progression
      if(enemies.length===0 && nextWaveIn<=0){ nextWaveIn = 180; statusEl.textContent = 'Next wave soon...'; }
      if(nextWaveIn>0){ nextWaveIn--; if(nextWaveIn===0) { nextWave(); } }

      // Occasional spawns to keep action
      if(Math.random()<0.01) spawnCrate();
      if(Math.random()<0.02) spawnEnemy(Math.random()<0.35?'shooter':'runner');

      updateHUD();
      renderer.render(scene, camera);
      requestAnimationFrame(step);
    }

    function gameOver(){
      state.gameOver = true; statusEl.textContent = 'You are down!';
      toast('GAME OVER ‚Äî press F5 to restart');
      overlay.style.display = 'grid';
      overlay.querySelector('h1').textContent = 'Game Over';
      overlay.querySelector('p').textContent = `Score: ${state.score} ‚Äî refresh to try again!`;
    }

    // Start first wave after lock
    controls.addEventListener('lock', ()=>{
      if(state.wave===1 && enemies.length===0) spawnWave(enemiesPerWave);
      requestAnimationFrame(step);
    });

  </script>
</body>
</html>
